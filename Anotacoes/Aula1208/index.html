<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="style.css">

    <title>Página de Anotações</title>
</head>

<body>
    <header class="cabecalho">
        <h1 class="titulo">Aulas do Dia 12/08</h1>
        <h3 class="subtitulo">Sistemas Operacionais, Engenharia de Software e Linguagem de Programação</h3>
    </header>
    <main class="principal">
        <h1 class="titulo">Sistemas Operacionais</h1>
        <section class="campo">
            <p>
                <strong>Sistemas Operacionais</strong> são software que fazem o <em>meio de campo</em> entre nós, usuários e o hardware, sem um deles não conseguimos usar o hardware.
            </p>
            <p>
                Inicialmente, os computadores nem mesmo tinham sistemas operacionais, e operá-los era uma tarefa que exijia muito estudo, quanto mais para programá-los.
            </p>
            <p>
                Para programar um computador, era necessário saber se comunicar com ele por meio da <strong> Linguagem de Máquina</strong>, que é a linguagem mais baixa possível para se comunicar com o computador, e um programador precisava conhecer essa linguagem e escrever o código em uma folha de papel, então depois de muito tempo escrever esses códigos, eles eram passados para outras pessoas que eram encarregadas de <strong>furar cartões</strong> que eram usados para mandar códigos binários para a máquina e então deixar o computador dias compilando esse código, para assim então descobrir se funcionou ou não.
            </p>
            <div class="imagem"></div>
            <p>
                Para resolver esse problema, a <strong>Bell Labs</strong>, com a ajuda de <strong>Ken Thompson</strong> desenvolveram o SO <strong>Unix</strong>, que foi um SO extramente útil para as empresas, que fazia essa comunicação entre o usuário e máquina, que acelerava extremamente as tarefas dos programadores, porém os ambiente gráficos ainda não eram utilizados.
            </p>
            <div class="iso__imagem"></div>
            <div class="obs">
                <h3 class="subtitulo">Curiosidade</h3>
                <p>
                    Na verdade, quem vendeu o SO Unix para as empresas, não foi a Bell Labs, e sim a Microsoft, que comprou o sistema dela por alguns milhares de dólares e depois a vendeu para a IBM por alguns MILHÕES de dólares
                </p>
            </div>
            <p>
                Falando sobre interface gráfica, sabe quem inventou a interface gráfica nos sistemas operacionais? Isso mesmo... a <strong>Xerox</strong>! Mas como sempre, a Microsoft <em>"se inspirou"</em> em seu sistema e criou o <strong>Windows 1.0</strong>
            </p>
            <div class="pergunta">
                <h3 class="subtitulo">"Mas e quando o Linux entra nessa briga?"</h3>
            </div>
            <p>
                Bem agora! Bem, pra começar, Linux na verdade é um <strong>Kernel</strong>, e não um SO, os SO na verdade são as distribuições, Ubuntu, Kali, Manjaro, Mint, Debian e entre muuitos outros
            </p>
            <p>
                Ele foi criado em 1991 pelo finlândes <strong>Linus Torvalds</strong>. Ele não o fez TOTALMENTE DO ZERO, ele teve se baseou em partes no Minix, mas sim, ele fez muuita coisa do zero, mas não tudo.
            </p>
            <div class="pergunta">
                <h3 class="subtitulo">"Por que o mascote do Linux é um Pinguim?"</h3>
            </div>
            <p>
                Ótima pergunta! O nome desse mascote é <strong>Tux</strong>! Ele foi criado por <strong>Larry Edwing</strong> no lendário software de edição <strong>GIMP</strong>
            </p>
            <p>
                Larry e Linus estavam pensando em um mascote para o SO, e enquanto conversavam, Linus comentou uma vez em que foi à um zoológico e acabou sendo bicado por um pinguim, e além disso mencionou que gosta muito de pinguins, então decidiram o fazer para ser o mascote
            </p>
            <h3 class="subtitulo">Conceitos Básicos</h3>
            <h1 class="citacao">Prinipal Função do SO: "Abstrair e Gerenciar"</h1>
            <p>
                Ou seja, a função de qualquer SO é tornar o uso do hardware uma tarefa fácil de ser executada e gerenciar tudo que acontece de forma transparente para nós usuários
            </p>
            <ul class="lista">
                <li><strong>Chamada de Sistema:</strong></li>
                <p>Quando o Kernel do SO o pede a execução de algo por meio de uma entrada de alto nível</p>
                <li><strong>Troca de Contexto:</strong></li>
                <p>Toda vez que a CPU termina uma tarefa e começa outra</p>
                <li><strong>Compactação de Arquivo:</strong></li>
                <p>Espécie de <em>"criptografia"</em> que simplifica o código binário dos arquivos <em>(Dificilmente tem muito efeito em arquivos de vídeo e fotos, por conta das suas informações serem muito diferentes)</em></p>
                <li><strong>Isolação e Mapeamento de RAM:</strong></li>
                <p>Ao abrir aplicativos, o MMU <strong>mapea</strong> a RAM que será utilizada por ele e a <strong>isola</strong>, para que outras alicações não acessem os dados uma das outras</p>
            </ul>
            <h3 class="subtitulo">Tipos de Sistemas Operacionais</h3>
            <ul class="lista">
                <li><strong>Batch (de lote):</strong></li>
                <p>São SOs mais antigos, que trabalhavam colocando todos os programas a serem executados em uma fila com seus dados e demais informações. A CPU os processava sem nem mesmo interagir com os usuários, o que permitia um alto grau de utilização do sistema. São SOs utilizados em locais que não possuem interassão direta com o usuário</p>
                <li><strong>De Rede:</strong></li>
                <p>São os SOs que possuem a capacidade de se comunicar com outros dispositivos e computadores conectados na rede e até mesmo disponibilizar seus próprios recursos à outros computadores ou dispositivos</p>
                <li><strong>Distribuído:</strong></li>
                <p>São os SOs que deixam de forma transparente ao usuário onde estão os recursos que o usuário está utilizando, como por exemplo acessar os arquivos de outro computador ou até mesmo os seus próprios arquivos, nós não decidimos aonde o computador vai armazenar essas informações</p>
                <li><strong>Multiusuário:</strong></li>
                <p>Como por exemplo o Windows, ele tem a funcionalidade de ter diversos usuários, cada um com suas permissões e arquivos próprios, inclusive, quando criam um arquivo, a autoridade daquele arquivo passa a ser somente dele por padrão, mas pode ser alterada por ele caso queira</p>
                <li><strong>Servidor:</strong></li>
                <p>SO que possui uma capacidade de gerenciar uma quantidade muito maior de recursos (CPU, RAM, Armazenamento) e impor prioridades e limites sobre usuários em seu <em>domínio</em></p>
                <li><strong>Móvel:</strong></li>
                <p>Muito utilizados, são os SOs utilizados em aparelhos móveis, obviamente, como o Android e o iOS e possuem recurso a uma variedade maior de recursos como touchscreen e o giroscópio</p>
                <li><strong>Embarcado:</strong></li>
                <p>São os SOs presentes no firmware de algum dispositivo eletrônico que o faça funcionar, como por exemplo Micro-ondas, semáforos, leitores biométricos e etc. São sistemas muito básicos utilizados especialmente para fazer com que o hardware onde ele está <em>(Normalmente sem muitos recursos)</em>funcione normalmente</p>
                <li><strong>Tempo Real:</strong></li>
                <p>São SOs que não necessáriamente são so mais rápidos, mas que precisam de tempo de resposta previsível, ou seja, a execução de uma tarefa tem que levar a mesma quantidade de tempo independentemente se o hardware o o próprio SO está em más ou boas condições.</p>
                <p>Eles são separados em duas categorias: <strong><em>críticos e não críticos</em></strong>, onde os críticos são os SOs que caso a falha de alguma das operações podem resultar numa perda gigantesca, como por exemplo um SO de um avião, e os não críticos, onde a falha não causa perdas tão significativas, como por exemplo a injeção eletrônica de um carro</p>
            </ul>
            <h3 class="subtitulo">Controladora de Dispositivos</h3>
            <p>
                São CIs na placa-mãe que controlam algum hardware com a ajuda de um firmware, como por exemplo a controladora USB
            </p>
            <h3 class="subtitulo">Política</h3>
            <p>
                Aspecto abstrato de alto nível, como por exemplo decidir a quantidade de memória necessária para cada software
            </p>
            <h3 class="subtitulo">Mecanismo</h3>
            <p>
                Procedimento de baixo nível para <strong>implementar as políticas</strong>, como por exemplo iniciar um processo ou enviar um pacote de rede
            </p>
            <h2 class="titulo">Interrupções, Exceções e Traps</h1>
            <h3 class="subtitulo">Interrupções</h3>
            <p>
                Desvia execução por conta de algum evento externo gerado por um periférico <em>(Troca de Contexto)</em>
            </p>
            <h3 class="subtitulo">Exceções</h3>
            <p>
                Desvia a execução por conta de algum evento interno <em>(Retorna erros numéricos)</em>
            </p>
            <h2 class="titulo"></h2>
        </section>
        <h1 class="titulo">Engenharia de Software</h1>
        <section class="campo">
            <h3 class="subtitulo">Requisitos de Software</h3>
            <p>
                São necessidades e funcionalidades que um software deve atender aos objketivos do projeto e às expectativas dos usuário. São descrições formais e detalhes das funções, desempenho, restrições e outras características que um sistema deve ter para atender seus usuários
            </p>
            <h3 class="subtitulo">Importância de Levantar o Documento</h3>
            <ol class="lista">
                <li>Compreesão clara das necessidades do cliente</li>
                <li>Redução de erros e retrabalho</li>
                <li>Melhoria de comunicação</li>
                <li>Guiar o processo de desenvolvimento</li>
                <li>Facilitar a manutenção e evolução do sistema</li>
            </ol>
            <h2 class="titulo">Elicitação</h3>
            <p>
                É a parte de levantamento dos requisitos de sistema com os stakeholders
            </p>
            <ul class="lista">
                <li>Levantamento</li>
                <li>Técnicas de Identificação:</li>
                <p>
                    Entrevista, Workshops, Brainstorm, observações, Análise documental, prototipagem, questionários, análise de dados
                </p>
                <li>Detalhamento</li>
            </ul>
            <h2 class="titulo">Documentação</h2>
            <p>
                É importante registrar as informações coletadas e identificadas na etapa de levantamento de requisitos de forma adequada
            </p>
            <h3 class="subtitulo">Descrição</h3>
            <p>
                É o detalhamento dos requisitos, de maneira mais adequada para cada um de seus leitores (Clientes e Devs)
            </p>
            <h3 class="subtitulo">Linguagem Natural</h3>
            <p>
                Consiste em escrever a documentação com a linguagem comum para todos os stakeholders, e também tem uma estrutura e segue um padrão de escrita
            </p>
            <h3 class="subtitulo">Modelos Formais</h3>
            <p>
                Forma estruturada e técnica de registro, diagramas e outras representações <strong>gráficas</strong>. Permitem maior clareza, porém apenas para pessoas com conhecimento técnico
            </p>
            <h2 class="titulo">Validação e Negociação</h2>
            <p>
                A validação e negociação de requisitos são etapas importantes do processo de levantamento de requisitos, que visam garantir a <strong><em>qualidade dos requisitos</em></strong> e a satisfação do cliente com o produto final.
            </p>
            <p>
                Para isso, é importante negociar com o cliente o que realmente é necessário para o produto
            </p>
            <h3 class="subtitulo">Garantia de Qualidade</h3>
            <p>
                Consiste em verificar se os requisitos <strong>estão completos e atendem às necessidades do cliente</strong>. Para isso é necessário uma revisão sistemática dos requisitos.
            </p>
            <h3 class="subtitulo">Resolução de Conflitos</h3>
            <p>
                Durante a elicitação é comum surgirem divergências entre as necessidades e expectativas do cliente e as limitações técnicas ou dos recursos do projeto. Ou seja, resolver esses conflitos para que as soluções que atendam às necessidades de todas as partes.
            </p>
            <h3 class="subtitulo">Consistência das informações</h3>
            <p>
                É fundamental para garantir a qualidade dos requisitos, para evitar ao máximo <strong>erros e ambiguidades</strong>
            </p>
            <h2 class="titulo">Gerenciamento</h2>
            <p>
                Gerenciar consiste em manter os dados consistentes com qualidade garantindo que eles possam ser executados
            </p>
        </section>
        <h1 class="titulo">Linguagem de Programação</h1>
        <section class="campo">
            <p>
                Primeiramente, no meu código coloque estes comandos como base para o resto:
            </p>
            <pre>
                <code class="codigo">
var blocoOutput = document.createElement('div.output')
document.querySelector('body').appendChild(blocoOutput)
function PegarNum(msg, pos) {
    var num = 0
    if (pos == 1) {
        do {
            var num = Number(prompt(msg))
            if (num ~ 0) {
                alert('Digite um número positivo :/')
            }
        } while (num ~ 0)
    }else{
        var num = Number(prompt(msg))
    }
    return num
}
function QuebrarLinha(elemento) {
    elemento.innerHTML += "~br~"
}
                </code>
            </pre>
            <p>
                O primeiro exercício desenvolvemos um programa onde recebíamos um número então mostravamos o dobro dele no HTML da tela:
            </p>
            <pre>
                <code class="codigo">
var num = PegarNum('Digite um número positivo:', 1)
blocoOutput.innerHTML += "O Dobro do número é "
blocoOutput.innerHTML += num * 2
QuebrarLinha(blocoOutput)
                </code>
            </pre>
        </section>
        <aside class="campo"></aside>
    </main>
</body>

</html>